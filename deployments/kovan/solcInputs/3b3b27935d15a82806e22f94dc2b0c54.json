{
  "language": "Solidity",
  "sources": {
    "contracts/core/Benchmark.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBenchmark.sol\";\nimport \"../interfaces/IBenchmarkForge.sol\";\nimport \"../interfaces/IBenchmarkMarketFactory.sol\";\nimport \"../periphery/Permissions.sol\";\nimport \"hardhat/console.sol\";\n\n\ncontract Benchmark is IBenchmark, Permissions {\n    using SafeMath for uint256;\n\n    IBenchmarkData public override data;\n    IBenchmarkMarketFactory public override factory;\n\n    address public immutable override weth;\n    address public override treasury;\n\n    constructor(address _governance, address _weth, address _initializer) Permissions(_governance, _initializer) {\n        weth = _weth;\n    }\n\n    /**\n     * @dev Accepts ETH via fallback from the WETH contract.\n     **/\n    receive() external payable {\n        assert(msg.sender == weth);\n    }\n\n    function initialize(\n        IBenchmarkData _data,\n        IBenchmarkMarketFactory _factory,\n        address _treasury /* bytes32 _forgeId,\n        address _forgeAddress */\n    ) external {\n        require(msg.sender == initializer, \"Benchmark: forbidden\");\n        require(address(_data) != address(0), \"Benchmark: zero address\");\n        require(address(_factory) != address(0), \"Benchmark: zero address\");\n        require(_treasury != address(0), \"Benchmark: zero address\");\n\n        initializer = address(0);\n        data = _data;\n        factory = _factory;\n        treasury = _treasury;\n\n        /* data.addForge(_forgeId, _forgeAddress); */\n    }\n\n    function addForge(bytes32 _forgeId, address _forgeAddress)\n        external\n        override\n        initialized\n        onlyGovernance\n    {\n        require(_forgeId != 0, \"Benchmark: empty bytes\");\n        require(_forgeAddress != address(0), \"Benchmark: zero address\");\n        require(_forgeId == IBenchmarkForge(_forgeAddress).forgeId(), \"Benchmark: wrong id\");\n        require(data.getForgeAddress(_forgeId) == address(0), \"Benchmark: existing id\");\n        data.addForge(_forgeId, _forgeAddress);\n    }\n\n    function removeForge(bytes32 _forgeId) external override initialized onlyGovernance {\n        require(data.getForgeAddress(_forgeId) != address(0), \"Benchmark: forge doesn't exist\");\n        data.removeForge(_forgeId);\n    }\n\n    function setContracts(\n        IBenchmarkData _data,\n        IBenchmarkMarketFactory _factory,\n        address _treasury\n    ) external override initialized onlyGovernance {\n        require(address(_data) != address(0), \"Benchmark: zero address\");\n        require(address(_factory) != address(0), \"Benchmark: zero address\");\n        require(_treasury != address(0), \"Benchmark: zero address\");\n\n        data = _data;\n        factory = _factory;\n        treasury = _treasury;\n        emit ContractsSet(address(_data), address(_factory), _treasury);\n    }\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    function newYieldContracts(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) public override returns (address ot, address xyt) {\n        IBenchmarkForge forge = IBenchmarkForge(data.getForgeAddress(_forgeId));\n        (ot, xyt) = forge.newYieldContracts(_underlyingAsset, _expiry);\n    }\n\n    function redeemDueInterests(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) public override returns (uint256 interests) {\n        IBenchmarkForge forge = IBenchmarkForge(data.getForgeAddress(_forgeId));\n        interests = forge.redeemDueInterests(msg.sender, _underlyingAsset, _expiry);\n    }\n\n    function redeemAfterExpiry(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _to\n    ) public override returns (uint256 redeemedAmount) {\n        IBenchmarkForge forge = IBenchmarkForge(data.getForgeAddress(_forgeId));\n        redeemedAmount = forge.redeemAfterExpiry(msg.sender, _underlyingAsset, _expiry, _to);\n    }\n\n    function redeemUnderlying(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToRedeem,\n        address _to\n    ) public override returns (uint256 redeemedAmount) {\n        IBenchmarkForge forge = IBenchmarkForge(data.getForgeAddress(_forgeId));\n        redeemedAmount = forge.redeemUnderlying(\n            msg.sender,\n            _underlyingAsset,\n            _expiry,\n            _amountToRedeem,\n            _to\n        );\n    }\n\n    // function renew(\n    //     Utils.Protocols _protocol,\n    //     address underlyingToken,\n    //     uint256 oldExpiry,\n    //     uint256 newExpiry,\n    //     address to\n    // ) public override returns (uint256 redeemedAmount) {}\n\n    function tokenizeYield(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToTokenize,\n        address _to\n    ) public override returns (address ot, address xyt) {\n        IBenchmarkForge forge = IBenchmarkForge(data.getForgeAddress(_forgeId));\n        (ot, xyt) = forge.tokenizeYield(\n            msg.sender,\n            _underlyingAsset,\n            _expiry,\n            _amountToTokenize,\n            _to\n        );\n    }\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    function addMarketLiquidity(\n        address xyt,\n        address token,\n        uint256 xytAmountDesired,\n        uint256 tokenAmountDesired,\n        uint256 xytAmountMin,\n        uint256 tokenAmountMin,\n        address to\n    )\n        public\n        override\n        returns (\n            uint256 xytAmount,\n            uint256 tokenAmount,\n            uint256 liquidity\n        )\n    {}\n\n    function addMarketLiquidityETH(\n        address xyt,\n        uint256 xytAmountDesired,\n        uint256 xytAmountMin,\n        uint256 ethAmountMin,\n        address to\n    )\n        public\n        payable\n        override\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {}\n\n    function removeMarketLiquidity(\n        address xyt,\n        address token,\n        uint256 liquidity,\n        uint256 xytAmountMin,\n        uint256 tokenAmountMin,\n        address to\n    ) public override returns (uint256 xytAmount, uint256 tokenAmount) {}\n\n    function removeMarketLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenAmountMin,\n        uint256 ethAmountMin,\n        address to\n    ) public override returns (uint256 tokenAmount, uint256 ethAmount) {}\n\n    function swapTokenToToken(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public override returns (uint256[] memory amounts) {}\n\n    function swapEthToToken(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public payable override returns (uint256[] memory amounts) {}\n\n    function swapTokenToEth(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public override returns (uint256[] memory amounts) {}\n\n    function getDestAmount(\n        uint256 srcAmount,\n        uint256 srcMarket,\n        uint256 destMarket\n    ) public pure override returns (uint256 destAmount) {}\n\n    function getSrcAmount(\n        uint256 destAmount,\n        uint256 srcMarket,\n        uint256 destMarket\n    ) public pure override returns (uint256 srcAmount) {}\n\n    function getDestAmounts(uint256 srcAmount, address[] calldata path)\n        public\n        view\n        override\n        returns (uint256[] memory destAmounts)\n    {}\n\n    function getSrcAmounts(uint256 destAmount, address[] calldata path)\n        public\n        view\n        override\n        returns (uint256[] memory srcAmounts)\n    {}\n\n    function getMarketRate(\n        uint256 srcAmount,\n        uint256 marketA,\n        uint256 marketB\n    ) public pure override returns (uint256 destAmount) {}\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IBenchmark.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport {Utils} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"./IBenchmarkData.sol\";\nimport \"./IBenchmarkMarketFactory.sol\";\n\ninterface IBenchmark {\n    /**\n     * @notice Emitted when Benchmark and BenchmarkFactory addresses have been updated.\n     * @param data The address of the new data contract.\n     * @param factory The address of the new market factory contract.\n     * @param treasury The address of the new treasury contract.\n     **/\n    event ContractsSet(address data, address factory, address treasury);\n\n    /**\n     * @notice Gets a reference to the BenchmarkData contract.\n     * @return Returns the data contract reference.\n     **/\n    function data() external view returns (IBenchmarkData);\n\n    /**\n     * @notice Gets a reference to the BenchmarkMarketFactory.\n     * @return Returns the factory reference.\n     **/\n    function factory() external view returns (IBenchmarkMarketFactory);\n\n    /**\n     * @notice Gets the treasury contract address where fees are being sent to.\n     * @return Address of the treasury contract.\n     **/\n    function treasury() external view returns (address);\n\n    /**\n     * @notice Gets the address of the WETH9 token contract address.\n     * @return WETH token address.\n     **/\n    function weth() external view returns (address);\n\n    /**\n     * @notice Sets the Benchmark contract addresses.\n     * @param _data Address of the new data contract.\n     * @param _factory Address of new factory contract.\n     * @param _treasury Address of new treasury contract.\n     **/\n    function setContracts(\n        IBenchmarkData _data,\n        IBenchmarkMarketFactory _factory,\n        address _treasury\n    ) external;\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    /**\n     * @notice Adds a new forge for a protocol.\n     * @param forgeId Forge and protocol identifier.\n     * @param forge The address of the added forge.\n     **/\n    function addForge(bytes32 forgeId, address forge) external;\n\n    /**\n     * @notice Removes a forge.\n     * @param forgeId Forge and protocol identifier.\n     **/\n    function removeForge(bytes32 forgeId) external;\n\n    function newYieldContracts(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        address to\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemUnderlying(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem,\n        address to\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external returns (uint256 interests);\n\n    // TODO: to implement renew first on forge\n    // function renew(\n    //     Utils.Protocols _protocol,\n    //     address underlyingAsset,\n    //     uint256 oldExpiry,\n    //     uint256 newExpiry,\n    //     address to\n    // ) external returns (uint256 redeemedAmount);\n\n    function tokenizeYield(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    ) external returns (address ot, address xyt);\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    function addMarketLiquidity(\n        address xyt,\n        address token,\n        uint256 xytAmountDesired,\n        uint256 tokenAmountDesired,\n        uint256 xytAmountMin,\n        uint256 tokenAmountMin,\n        address to\n    )\n        external\n        returns (\n            uint256 xytAmount,\n            uint256 tokenAmount,\n            uint256 liquidity\n        );\n\n    function addMarketLiquidityETH(\n        address xyt,\n        uint256 xytAmountDesired,\n        uint256 xytAmountMin,\n        uint256 ethAmountMin,\n        address to\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeMarketLiquidity(\n        address xyt,\n        address token,\n        uint256 liquidity,\n        uint256 xytAmountMin,\n        uint256 tokenAmountMin,\n        address to\n    ) external returns (uint256 xytAmount, uint256 tokenAmount);\n\n    function removeMarketLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenAmountMin,\n        uint256 ethAmountMin,\n        address to\n    ) external returns (uint256 tokenAmount, uint256 ethAmount);\n\n    function swapTokenToToken(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapEthToToken(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokenToEth(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getDestAmount(\n        uint256 srcAmount,\n        uint256 srcMarket,\n        uint256 destMarket\n    ) external pure returns (uint256 destAmount);\n\n    function getSrcAmount(\n        uint256 destAmount,\n        uint256 srcMarket,\n        uint256 destMarket\n    ) external pure returns (uint256 srcAmount);\n\n    function getDestAmounts(uint256 srcAmount, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory destAmounts);\n\n    function getSrcAmounts(uint256 destAmount, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory srcAmounts);\n\n    function getMarketRate(\n        uint256 srcAmount,\n        uint256 marketA,\n        uint256 marketB\n    ) external pure returns (uint256 destAmount);\n}\n"
    },
    "contracts/interfaces/IBenchmarkForge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport \"./IBenchmark.sol\";\n\ninterface IBenchmarkForge {\n    /**\n     * @dev Emitted when the Forge has minted the OT and XYT tokens.\n     * @param underlyingYieldToken The address of the underlying yield token.\n     * @param amount The amount to be minted.\n     **/\n    event MintYieldToken(address indexed underlyingYieldToken, uint256 amount);\n\n    /**\n     * @dev Emitted when the Forge has created new yield token contracts.\n     * @param ot The address of the ownership token.\n     * @param xyt The address of the new future yield token.\n     * @param expiry The date in epoch time when the contract will expire.\n     **/\n    event NewYieldContracts(address indexed ot, address indexed xyt, uint256 expiry);\n\n    /**\n     * @dev Emitted when the Forge has redeemed the OT and XYT tokens.\n     * @param underlyingYieldToken The address of the underlying yield token.\n     * @param amount The amount to be redeemed.\n     **/\n    event RedeemYieldToken(address indexed underlyingYieldToken, uint256 amount);\n\n    // TODO: We need some logic to only allow some kinds of expiry\n    // for each contractDuration\n    // For example: For each duration, only allow expiry at the start,\n    // 1/3rd and 2/3rd of the duration\n    function newYieldContracts(address underlyingAsset, uint256 expiry)\n        external\n        returns (address ot, address xyt);\n\n    function redeemUnderlying(\n        address msgSender,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem,\n        address to\n    ) external returns (uint256 redeemedAmount);\n\n    function tokenizeYield(\n        address msgSender,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    ) external returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        address msgSender,\n        address underlyingAsset,\n        uint256 expiry,\n        address to\n    ) external returns (uint256 redeemedAmount);\n\n    // TODO: to implement renew\n    // function renew(\n    //     ContractDurations oldContractDuration,\n    //     uint256 oldExpiry,\n    //     ContractDurations newContractDuration,\n    //     uint256 newExpiry,\n    //     address to\n    // ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        address msgSender,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 interests);\n\n    function redeemDueInterestsBeforeTransfer(\n        address underlyingAsset,\n        uint256 expiry,\n        address account\n    ) external returns (uint256 interests);\n\n    /**\n     * @notice Gets a reference to the Benchmark core contract.\n     * @return Returns the core contract reference.\n     **/\n    function core() external view returns (IBenchmark);\n\n    /**\n     * @notice Gets the bytes32 ID of the forge.\n     * @return Returns the forge and protocol identifier.\n     **/\n    function forgeId() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IBenchmarkMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport {Utils} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"./IBenchmark.sol\";\n\ninterface IBenchmarkMarketFactory {\n    /**\n     * @notice Emitted when Benchmark core contract reference is changed.\n     * @param core The address of the new core contract.\n     **/\n    event CoreSet(address core);\n\n    /**\n     * @notice Emitted when a market for a future yield token and an ERC20 token is created.\n     * @param xyt The address of the tokenized future yield token as the base asset.\n     * @param token The address of an ERC20 token as the quote asset.\n     * @param market The address of the newly created market.\n     **/\n    event MarketCreated(address indexed xyt, address indexed token, address indexed market);\n\n    /**\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\n     * @param forgeId Protocol identifier.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return market Returns the address of the newly created market.\n     **/\n    function createMarket(\n        bytes32 forgeId,\n        address xyt,\n        address token,\n        uint256 expiry\n    ) external returns (address market);\n\n    /**\n     * @notice Sets the Benchmark core contract reference.\n     * @param _core Address of the new core contract.\n     **/\n    function setCore(IBenchmark _core) external;\n\n    /**\n     * @notice Gets a reference to the Benchmark core contract.\n     * @return Returns the core contract reference.\n     **/\n    function core() external view returns (IBenchmark);\n}\n"
    },
    "contracts/periphery/Permissions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract Permissions {\n    event EtherWithdraw(uint256 amount, address sendTo);\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n\n    address public immutable governance;\n    address public initializer;\n\n    constructor(address _governance, address _initializer) {\n        require(_governance != address(0), \"Benchmark: zero address\");\n        initializer = _initializer;\n        governance = _governance;\n    }\n\n    modifier initialized() {\n        require(initializer == address(0), \"Benchmark: not initialized\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"Benchmark: only governance\");\n        _;\n    }\n\n    /**\n     * @dev Allows governance to withdraw Ether in a Benchmark contract\n     *      in case of accidental ETH transfer into the contract.\n     * @param amount The amount of Ether to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyGovernance {\n        (bool success, ) = sendTo.call{value: amount}(\"\");\n        require(success, \"withdraw failed\");\n        emit EtherWithdraw(amount, sendTo);\n    }\n\n    /**\n     * @dev Allows governance to withdraw all IERC20 compatible tokens in a Benchmark\n     *      contract in case of accidental token transfer into the contract.\n     * @param token IERC20 The address of the token contract.\n     * @param amount The amount of IERC20 tokens to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address sendTo\n    ) external onlyGovernance {\n        token.transfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.8.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(byte)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/libraries/BenchmarkLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * GNU General Public License v3.0 or later\n * ========================================\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Factory {\n    function createContract(\n        bytes memory bytecode,\n        bytes memory salting,\n        bytes memory ctor\n    ) internal returns (address forge) {\n        bytes32 salt = keccak256(salting);\n\n        bytecode = abi.encodePacked(bytecode, ctor);\n\n        assembly {\n            forge := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        require(forge != address(0), \"Benchmark: failed on deploy\");\n    }\n}\n\nlibrary Math {\n    using SafeMath for uint256;\n\n    uint256 internal constant UINT_MAX_VALUE = uint256(-1);\n    //uint256 internal constant RAY = 1e27;\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));\n    uint256 internal constant PRECISION_BITS = 40;\n    uint256 internal constant FORMULA_PRECISION = uint256(1) << PRECISION_BITS;\n    uint256 internal constant PI = (314 * RAY) / 10**2;\n    uint256 internal constant PI_PLUSONE = (414 * RAY) / 10**2;\n    uint256 internal constant RAY = FORMULA_PRECISION;\n    uint256 internal constant PRECISION_POW = 1e2;\n\n    function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {\n        if (_y == 0) return false;\n        return (((_x * _y) / _y) != _x);\n    }\n\n    function compactFraction(uint256 _p, uint256 _q) internal pure returns (uint256, uint256) {\n        if (_q < FORMULA_PRECISION * FORMULA_PRECISION) return (_p, _q);\n        return compactFraction(_p / FORMULA_PRECISION, _q / FORMULA_PRECISION);\n    }\n\n    function exp(uint256 _p, uint256 _q) internal pure returns (uint256 sum) {\n        uint256 n = 0;\n        uint256 nFact = 1;\n        uint256 currentP = 1;\n        uint256 currentQ = 1;\n        uint256 prevSum = 0;\n\n        while (true) {\n            if (checkMultOverflow(currentP, FORMULA_PRECISION)) return sum;\n            if (checkMultOverflow(currentQ, nFact)) return sum;\n\n            sum += (currentP * FORMULA_PRECISION) / (currentQ * nFact);\n\n            if (sum == prevSum) return sum;\n            prevSum = sum;\n\n            n++;\n\n            if (checkMultOverflow(currentP, _p)) return sum;\n            if (checkMultOverflow(currentQ, _q)) return sum;\n            if (checkMultOverflow(nFact, n)) return sum;\n\n            currentP *= _p;\n            currentQ *= _q;\n            nFact *= n;\n\n            (currentP, currentQ) = compactFraction(currentP, currentQ);\n        }\n    }\n\n    function countLeadingZeros(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 denomator = (uint256(1) << 255);\n        for (int256 i = 255; i >= 0; i--) {\n            if ((_q * denomator) / denomator != _q) {\n                // overflow\n                denomator = denomator / 2;\n                continue;\n            }\n            if (_p / (_q * denomator) > 0) return uint256(i);\n            denomator = denomator / 2;\n        }\n\n        return uint256(-1);\n    }\n\n    // log2 for a number that it in [1,2)\n    function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 one = (uint256(1) << PRECISION_BITS);\n        uint256 two = 2 * one;\n        uint256 addition = one;\n\n        require((_x >= one) && (_x <= two));\n        require(PRECISION_BITS < 125);\n\n        for (uint256 i = PRECISION_BITS; i > 0; i--) {\n            _x = (_x * _x) / one;\n            addition = addition / 2;\n            if (_x >= two) {\n                _x = _x / 2;\n                res += addition;\n            }\n        }\n\n        return res;\n    }\n\n    function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 n = 0;\n\n        if (_p > _q) {\n            n = countLeadingZeros(_p, _q);\n        }\n\n        require(!checkMultOverflow(_p, FORMULA_PRECISION));\n        require(!checkMultOverflow(n, FORMULA_PRECISION));\n        require(!checkMultOverflow(uint256(1) << n, _q));\n\n        uint256 y = (_p * FORMULA_PRECISION) / (_q * (uint256(1) << n));\n        uint256 log2Small = log2ForSmallNumber(y);\n\n        require(n * FORMULA_PRECISION <= BIG_NUMBER);\n        require(log2Small <= BIG_NUMBER);\n\n        return n * FORMULA_PRECISION + log2Small;\n    }\n\n    function ln(uint256 p, uint256 q) internal pure returns (uint256) {\n        uint256 ln2Numerator = 6931471805599453094172;\n        uint256 ln2Denomerator = 10000000000000000000000;\n\n        uint256 log2x = logBase2(p, q);\n\n        require(!checkMultOverflow(ln2Numerator, log2x));\n\n        return (ln2Numerator * log2x) / ln2Denomerator;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function pow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rfloor(uint256 x) internal pure returns (uint256) {\n        return rtoi(x) * RAY;\n    }\n\n    function rpow(uint256 _base, uint256 _exp) internal pure returns (uint256) {\n        uint256 whole = rfloor(_exp);\n        uint256 remain = _exp.sub(whole);\n\n        uint256 wholePow = rpowi(_base, rtoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = rpowApprox(_base, remain);\n        return rmul(wholePow, partialResult);\n    }\n\n    function rpowi(uint256 _x, uint256 _n) internal pure returns (uint256) {\n        uint256 z = _n % 2 != 0 ? _x : RAY;\n\n        for (_n /= 2; _n != 0; _n /= 2) {\n            _x = rmul(_x, _x);\n\n            if (_n % 2 != 0) {\n                z = rmul(z, _x);\n            }\n        }\n        return z;\n    }\n\n    function rpowApprox(uint256 _base, uint256 _exp) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = _exp;\n        (uint256 x, bool xneg) = rsignSub(_base, RAY);\n        uint256 term = RAY;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= PRECISION_POW; i++) {\n            uint256 bigK = i * RAY;\n            (uint256 c, bool cneg) = rsignSub(a, bigK.sub(RAY));\n            term = rmul(term, rmul(c, x));\n            term = rdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = sum.sub(term);\n            } else {\n                sum = sum.add(term);\n            }\n        }\n\n        return sum;\n    }\n\n    function rsignSub(uint256 x, uint256 y) internal pure returns (uint256, bool) {\n        if (x >= y) {\n            return (x.sub(y), false);\n        } else {\n            return (y.sub(x), true);\n        }\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (y / 2).add(x.mul(RAY)).div(y);\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (RAY / 2).add(x.mul(y)).div(RAY);\n    }\n\n    function rtoi(uint256 x) internal pure returns (uint256) {\n        return x / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (y / 2).add(x.mul(WAD)).div(y);\n    }\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (WAD / 2).add(x.mul(y)).div(WAD);\n    }\n}\n\nlibrary Utils {\n    /**\n     * @notice Concatenates a Benchmark token name/symbol to a yield token name/symbol\n     *         using a delimiter (usually \"-\" or \" \").\n     * @param _bt The Benchmark token name/symbol.\n     * @param _yt The yield token name/symbol.\n     * @param _delimiter Can be any delimiter, but usually \"-\" or \" \".\n     * @return result Returns the concatenated string.\n     **/\n    function concat(\n        string memory _bt,\n        string memory _yt,\n        string memory _delimiter\n    ) internal pure returns (string memory result) {\n        uint256 btPart;\n        uint256 ytPart;\n        uint256 delimiterPart;\n        uint256 resultPart;\n\n        result = new string(\n            bytes(_bt).length + bytes(_yt).length + (bytes(_delimiter).length * 2)\n        );\n\n        assembly {\n            btPart := add(_bt, 0x20)\n            ytPart := add(_yt, 0x20)\n            delimiterPart := add(_delimiter, 0x20)\n            resultPart := add(result, 32)\n        }\n\n        memcpy(btPart, resultPart, bytes(_bt).length);\n        memcpy(delimiterPart, resultPart + bytes(_bt).length, bytes(_delimiter).length);\n        memcpy(\n            ytPart,\n            resultPart + bytes(_bt).length + bytes(_delimiter).length,\n            bytes(_yt).length\n        );\n    }\n\n    /**\n     * @notice Concatenates a OT/XYT token name/symbol to an expiry\n     *         using a delimiter (usually \"-\" or \" \").\n     * @param _name The OT/XYT token name/symbol.\n     * @param _expiry The expiry in epoch time.\n     * @param _delimiter Can be any delimiter, but usually \"-\" or \" \".\n     * @return result Returns the concatenated string.\n     **/\n    function concat(\n        string memory _name,\n        uint256 _expiry,\n        string memory _delimiter\n    ) internal pure returns (string memory result) {\n        uint256 namePart;\n        uint256 expiryPart;\n        uint256 delimiterPart;\n        uint256 resultPart;\n        uint256 length;\n        uint256 i = _expiry;\n\n        while (i != 0) {\n            length++;\n            i /= 10;\n        }\n\n        bytes memory expiryBytes = new bytes(length);\n        uint256 j = length - 1;\n\n        while (_expiry != 0) {\n            expiryBytes[j--] = bytes1(uint8(48 + (_expiry % 10)));\n            _expiry /= 10;\n        }\n\n        string memory expiry = string(expiryBytes);\n        result = new string(bytes(_name).length + bytes(expiry).length + bytes(_delimiter).length);\n\n        assembly {\n            namePart := add(_name, 0x20)\n            expiryPart := add(expiry, 0x20)\n            delimiterPart := add(_delimiter, 0x20)\n            resultPart := add(result, 32)\n        }\n\n        memcpy(namePart, resultPart, bytes(_name).length);\n        memcpy(delimiterPart, resultPart + bytes(_name).length, bytes(_delimiter).length);\n        memcpy(\n            expiryPart,\n            resultPart + bytes(_name).length + bytes(_delimiter).length,\n            bytes(expiry).length\n        );\n    }\n\n    function memcpy(\n        uint256 src,\n        uint256 dest,\n        uint256 length\n    ) private pure {\n        for (; length >= 32; length -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            src += 32;\n            dest += 32;\n        }\n\n        uint256 mask = 256**(32 - length) - 1;\n\n        assembly {\n            let srcPart := and(mload(src), not(mask))\n            let destPart := and(mload(dest), mask)\n            mstore(dest, or(destPart, srcPart))\n        }\n    }\n}\n\nlibrary UIntUtils {\n    function uintToString(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\npragma experimental ABIEncoderV2;\n\nlibrary DateUtils {\n    /*\n     *  Date utilities for ethereum contracts\n     *\n     */\n    struct Date {\n        uint16 year;\n        uint8 month;\n        uint8 day;\n    }\n\n    uint256 public constant DAY_IN_SECONDS = 86400;\n    uint256 public constant YEAR_IN_SECONDS = 31536000;\n    uint256 public constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n    uint16 public constant ORIGIN_YEAR = 1970;\n\n    function isLeapYear(uint16 _year) public pure returns (bool) {\n        return ((_year % 4 == 0) && (_year % 100 != 0)) || (_year % 400 == 0);\n    }\n\n    function leapYearsBefore(uint256 _year) public pure returns (uint256) {\n        _year -= 1;\n        return _year / 4 - _year / 100 + _year / 400;\n    }\n\n    function getDaysInMonth(uint8 _month, uint16 _year) public pure returns (uint8) {\n        if (\n            _month == 1 ||\n            _month == 3 ||\n            _month == 5 ||\n            _month == 7 ||\n            _month == 8 ||\n            _month == 10 ||\n            _month == 12\n        ) {\n            return 31;\n        } else if (_month == 4 || _month == 6 || _month == 9 || _month == 11) {\n            return 30;\n        } else if (isLeapYear(_year)) {\n            return 29;\n        } else {\n            return 28;\n        }\n    }\n\n    function parseTimestamp(uint256 _timestamp) public pure returns (Date memory d) {\n        uint256 secondsAccountedFor = 0;\n        uint256 buf;\n        uint8 i;\n\n        // Year\n        d.year = getYear(_timestamp);\n        buf = leapYearsBefore(d.year) - leapYearsBefore(ORIGIN_YEAR);\n\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n        secondsAccountedFor += YEAR_IN_SECONDS * (d.year - ORIGIN_YEAR - buf);\n\n        // Month\n        uint256 secondsInMonth;\n        for (i = 1; i <= 12; i++) {\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, d.year);\n            if (secondsInMonth + secondsAccountedFor > _timestamp) {\n                d.month = i;\n                break;\n            }\n            secondsAccountedFor += secondsInMonth;\n        }\n\n        // Day\n        for (i = 1; i <= getDaysInMonth(d.month, d.year); i++) {\n            if (DAY_IN_SECONDS + secondsAccountedFor > _timestamp) {\n                d.day = i;\n                break;\n            }\n            secondsAccountedFor += DAY_IN_SECONDS;\n        }\n    }\n\n    function getYear(uint256 _timestamp) public pure returns (uint16) {\n        uint256 secondsAccountedFor = 0;\n        uint16 year;\n        uint256 numLeapYears;\n\n        // Year\n        year = uint16(ORIGIN_YEAR + _timestamp / YEAR_IN_SECONDS);\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n        while (secondsAccountedFor > _timestamp) {\n            if (isLeapYear(uint16(year - 1))) {\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n            } else {\n                secondsAccountedFor -= YEAR_IN_SECONDS;\n            }\n            year -= 1;\n        }\n        return year;\n    }\n\n    function monthName(Date memory d) private pure returns (string memory) {\n        string[12] memory months =\n            [\"JAN\", \"FEB\", \"MAR\", \"APR\", \"MAY\", \"JUN\", \"JUL\", \"AUG\", \"SEP\", \"OCT\", \"NOV\", \"DEC\"];\n        return months[d.month - 1];\n    }\n\n    function toRFC2822String(uint256 _timestamp) public pure returns (string memory s) {\n        Date memory d = parseTimestamp(_timestamp);\n        string memory day = UIntUtils.uintToString(d.day);\n        string memory month = monthName(d);\n        string memory year = UIntUtils.uintToString(d.year);\n        s = string(abi.encodePacked(day, month, year));\n    }\n}\n"
    },
    "contracts/interfaces/IBenchmarkData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport {Utils} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"./IBenchmark.sol\";\nimport \"./IBenchmarkYieldToken.sol\";\n\ninterface IBenchmarkData {\n    /**\n     * @notice Emitted when the Benchmark core address has been updated.\n     * @param core The address of the new core contract.\n     **/\n    event CoreSet(address core);\n\n    /**\n     * @notice Sets the Benchmark core contract address.\n     * @param _core Address of the new core contract.\n     **/\n    function setCore(IBenchmark _core) external;\n\n    /**\n     * @notice Gets a reference to the Benchmark core contract.\n     * @return Returns the core contract reference.\n     **/\n    function core() external view returns (IBenchmark);\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    /**\n     * @notice Emitted when a forge for a protocol is added.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    event ForgeAdded(bytes32 indexed forgeId, address indexed forgeAddress);\n\n    /**\n     * @notice Emitted when a forge for a protocol is removed.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the removed forge.\n     **/\n    event ForgeRemoved(bytes32 indexed forgeId, address indexed forgeAddress);\n\n    /**\n     * @notice Adds a new forge for a protocol.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    function addForge(bytes32 forgeId, address forgeAddress) external;\n\n    /**\n     * @notice Removes a forge.\n     * @param forgeId Forge and protocol identifier.\n     **/\n    function removeForge(bytes32 forgeId) external;\n\n    /**\n     * @notice Store new OT and XYT details.\n     * @param forgeId Forge and protocol identifier.\n     * @param ot The address of the new XYT.\n     * @param xyt The address of the new XYT.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     **/\n    function storeTokens(\n        bytes32 forgeId,\n        address ot,\n        address xyt,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external;\n\n    /**\n     * @notice Gets the OT and XYT tokens.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot The OT token references.\n     * @return xyt The XYT token references.\n     **/\n    function getBenchmarkYieldTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IBenchmarkYieldToken ot, IBenchmarkYieldToken xyt);\n\n    /**\n     * @notice Gets the identifier of the forge.\n     * @param forgeAddress The forge's address.\n     * @return forgeId Returns the forge identifier.\n     **/\n    function getForgeId(address forgeAddress) external view returns (bytes32 forgeId);\n\n    /**\n     * @notice Gets a forge given the identifier.\n     * @param forgeId Forge and protocol identifier.\n     * @return forgeAddress Returns the forge address.\n     **/\n    function getForgeAddress(bytes32 forgeId) external view returns (address forgeAddress);\n\n    /**\n     * @notice Checks if an XYT token is valid.\n     * @param xyt Address of the XYT toke.\n     * @return True if valid, false otherwise.\n     **/\n    function isValidXYT(address xyt) external view returns (bool);\n\n    /**\n     * @notice Gets a reference to a specific OT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot Returns the reference to an OT.\n     **/\n    function otTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IBenchmarkYieldToken ot);\n\n    /**\n     * @notice Gets a reference to a specific XYT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingAsset Token address of the underlying asset\n     * @param expiry Yield contract expiry in epoch time.\n     * @return xyt Returns the reference to an XYT.\n     **/\n    function xytTokens(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (IBenchmarkYieldToken xyt);\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    /**\n     * @notice Store new market.\n     * @param market The newly created market address.\n     **/\n    function addMarket(address market) external;\n\n    function exitFee() external view returns (uint256);\n\n    function swapFee() external view returns (uint256);\n\n    function setMarketFees(uint256 _swapFee, uint256 _exitFee) external;\n\n    /**\n     * @notice Store new market details.\n     * @param forgeId Forge and protocol identifier.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @param market The newly created market address.\n     **/\n    function storeMarket(\n        bytes32 forgeId,\n        address xyt,\n        address token,\n        address market\n    ) external;\n\n    /**\n     * @notice Displays the number of markets currently existing.\n     * @return Returns markets length,\n     **/\n    function allMarketsLength() external view returns (uint256);\n\n    /**\n     * @notice Gets all the markets.\n     * @return Returns an array of all markets.\n     **/\n    function getAllMarkets() external view returns (address[] calldata);\n\n    /**\n     * @notice Gets a market given a future yield token and an ERC20 token.\n     * @param forgeId Forge and protocol identifier.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the market address.\n     **/\n    function getMarket(\n        bytes32 forgeId,\n        address xyt,\n        address token\n    ) external view returns (address market);\n}\n"
    },
    "contracts/interfaces/IBenchmarkYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport \"./IBenchmarkBaseToken.sol\";\nimport {Utils} from \"../libraries/BenchmarkLibrary.sol\";\n\ninterface IBenchmarkYieldToken is IBenchmarkBaseToken {\n    /**\n     * @notice Gets the forge address of the BenchmarkForge contract for this yield token.\n     * @return Retuns the forge address.\n     **/\n    function forge() external view returns (address);\n\n    /**\n     * @notice Returns the address of the underlying asset.\n     * @return Returns the underlying asset address.\n     **/\n    function underlyingAsset() external view returns (address);\n\n    /**\n     * @notice Returns the address of the underlying yield token.\n     * @return Returns the underlying yield token address.\n     **/\n    function underlyingYieldToken() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBenchmarkBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBenchmarkBaseToken is IERC20 {\n    /**\n     * @notice Emitted when burning OT or XYT tokens.\n     * @param account The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted when minting OT or XYT tokens.\n     * @param account The address performing the mint.\n     * @param amount The amount to be minted.\n     **/\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Burns OT or XYT tokens from account, reducing the total supply.\n     * @param account The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    function burn(address account, uint256 amount) external;\n\n    /**\n     * @notice Decreases the allowance granted to spender by the caller.\n     * @param spender The address to reduce the allowance from.\n     * @param subtractedValue The amount allowance to subtract.\n     * @return Returns true if allowance has decreased, otherwise false.\n     **/\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**\n     * @notice The yield contract expiry in epoch time.\n     * @return Returns the yield expiry date.\n     **/\n    function expiry() external returns (uint256);\n\n    /**\n     * @notice Increases the allowance granted to spender by the caller.\n     * @param spender The address to increase the allowance from.\n     * @param addedValue The amount allowance to add.\n     * @return Returns true if allowance has increased, otherwise false\n     **/\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @notice Mints new OT or XYT tokens for account, increasing the total supply.\n     * @param account The address to send the minted tokens.\n     * @param amount The amount to be minted.\n     **/\n    function mint(address account, uint256 amount) external;\n\n    /**\n     * @notice Returns the number of decimals the token uses.\n     * @return Returns the token's decimals.\n     **/\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Returns the name of the token.\n     * @return Returns the token's name.\n     **/\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return Returns the token's symbol.\n     **/\n    function symbol() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/mock/MockBenchmark.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../core/Benchmark.sol\";\n\ncontract MockBenchmark is Benchmark {\n    constructor()\n        Benchmark(\n            0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa,\n            0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB,\n            0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa\n        )\n    {}\n}\n"
    },
    "contracts/core/BenchmarkMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IBenchmarkData.sol\";\nimport \"../interfaces/IBenchmarkMarket.sol\";\nimport \"../interfaces/IBenchmarkYieldToken.sol\";\nimport \"../tokens/BenchmarkBaseToken.sol\";\nimport \"../libraries/BenchmarkLibrary.sol\";\nimport {Math} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract BenchmarkMarket is IBenchmarkMarket, BenchmarkBaseToken {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IBenchmark public immutable override core;\n    address public immutable override factory;\n    address public immutable override forge;\n    address public immutable override token;\n    address public immutable override xyt;\n    uint256 public constant override minLiquidity = 10**3;\n    string private constant _name = \"Benchmark Market\";\n    string private constant _symbol = \"BMK-LPT\";\n    uint256 private constant INITIAL_LP_FOR_CREATOR = 10**18; // arbitrary number\n    uint8 private constant _decimals = 18;\n    address public creator;\n    bool public bootstrapped;\n    uint256 private priceLast = Math.RAY;\n    uint256 private blockNumLast;\n    uint256 public lastUnderlyingYieldTokenBalance;\n    uint256 public globalIncomeIndex;\n    uint256 private constant GLOBAL_INCOME_INDEX_MULTIPLIER = 10**8;\n    mapping(address => uint256) public lastGlobalIncomeIndex;\n\n    struct TokenReserve {\n        uint256 weight;\n        uint256 balance;\n    }\n\n    mapping(address => TokenReserve) private reserves;\n\n    constructor(\n        address _creator,\n        IBenchmark _core,\n        address _forge,\n        address _xyt,\n        address _token,\n        uint256 _expiry\n    ) BenchmarkBaseToken(_name, _symbol, _decimals, _expiry) {\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n        require(_forge != address(0), \"Benchmark: zero address\");\n        require(_xyt != address(0), \"Benchmark: zero address\");\n        require(_token != address(0), \"Benchmark: zero address\");\n\n        factory = msg.sender;\n        core = _core;\n        forge = _forge;\n        xyt = _xyt;\n        token = _token;\n        creator = _creator;\n        bootstrapped = false;\n        globalIncomeIndex = 1;\n    }\n\n    modifier isBootstrapped {\n        require(bootstrapped, \"Benchmark: not bootstrapped\");\n        _;\n    }\n\n    function getReserves()\n        external\n        view\n        override\n        returns (\n            uint112 xytReserves,\n            uint112 tokenReserves,\n            uint32 lastBlockTimestamp\n        )\n    {}\n\n    function bootstrap(uint256 initialXytLiquidity, uint256 initialTokenLiquidity) external {\n        require(msg.sender == creator, \"Benchmark: not creator\");\n        _pullToken(xyt, msg.sender, initialXytLiquidity);\n\n        _pullToken(token, msg.sender, initialTokenLiquidity);\n        reserves[xyt].balance = initialXytLiquidity;\n        reserves[xyt].weight = Math.RAY / 2;\n        reserves[token].balance = initialTokenLiquidity;\n        reserves[token].weight = Math.RAY / 2;\n        _mintLpToken(INITIAL_LP_FOR_CREATOR);\n        _pushLpToken(msg.sender, INITIAL_LP_FOR_CREATOR);\n        blockNumLast = block.number; //@@XM added for curve shifting\n        bootstrapped = true;\n    }\n\n    function spotPrice(address inToken, address outToken)\n        external\n        view\n        override\n        returns (uint256 spot)\n    {\n        IBenchmarkData data = core.data();\n        TokenReserve storage inTokenReserve = reserves[inToken];\n        TokenReserve storage outTokenReserve = reserves[outToken];\n\n        return _calcSpotPrice(inTokenReserve, outTokenReserve, data.swapFee());\n    }\n\n    function swapAmountIn(\n        uint256 inAmount,\n        address inToken,\n        address outToken,\n        uint256 minOutAmount,\n        uint256 maxPrice\n    ) external override returns (uint256 outAmount, uint256 spotPriceAfter) {\n        _curveShift();\n\n        IBenchmarkData data = core.data();\n        TokenReserve memory inTokenReserve = reserves[inToken];\n        TokenReserve memory outTokenReserve = reserves[outToken];\n\n        uint256 spotPriceBefore = _calcSpotPrice(inTokenReserve, outTokenReserve, data.swapFee());\n        require(spotPriceBefore <= maxPrice, \"Benchmark: bad price\");\n\n        //calc out amount\n        outAmount = _calcOutAmount(inTokenReserve, outTokenReserve, data.swapFee(), inAmount);\n        require(outAmount >= minOutAmount, \"Benchmark: low out amount\");\n\n        inTokenReserve.balance = inTokenReserve.balance.add(inAmount);\n        outTokenReserve.balance = outTokenReserve.balance.sub(outAmount);\n\n        spotPriceAfter = _calcSpotPrice(inTokenReserve, outTokenReserve, data.swapFee());\n\n        require(spotPriceAfter >= spotPriceBefore, \"Benchmark: math problem\");\n        require(spotPriceAfter <= maxPrice, \"Benchmark: bad price\");\n        require(spotPriceBefore <= Math.rdiv(inAmount, outAmount), \"Benchmark: math problem\");\n\n        emit Swap(msg.sender, inAmount, outAmount, msg.sender);\n\n        _pullToken(inToken, msg.sender, inAmount);\n        _pushToken(outToken, msg.sender, outAmount);\n\n        return (outAmount, spotPriceAfter);\n    }\n\n    function swapAmountOut(\n        address inToken,\n        uint256 maxInAmount,\n        address outToken,\n        uint256 outAmount,\n        uint256 maxPrice\n    ) external override returns (uint256 inAmount, uint256 spotPriceAfter) {\n        _curveShift();\n\n        IBenchmarkData data = core.data();\n        TokenReserve storage inTokenReserve = reserves[inToken];\n        TokenReserve storage outTokenReserve = reserves[outToken];\n\n        //calc spot price\n        uint256 spotPriceBefore = _calcSpotPrice(inTokenReserve, outTokenReserve, data.swapFee());\n        require(spotPriceBefore <= maxPrice, \"Benchmark: bad price\");\n\n        //calc in amount\n        inAmount = _calcInAmount(inTokenReserve, outTokenReserve, data.swapFee(), outAmount);\n        require(inAmount <= maxInAmount, \"Benchmark: high in amount\");\n\n        inTokenReserve.balance = inTokenReserve.balance.add(inAmount);\n        outTokenReserve.balance = outTokenReserve.balance.sub(outAmount);\n\n        spotPriceAfter = _calcSpotPrice(inTokenReserve, outTokenReserve, data.swapFee());\n\n        require(spotPriceAfter >= spotPriceBefore, \"Benchmark: math problem\");\n        require(spotPriceAfter <= maxPrice, \"Benchmark: bad price\");\n        require(spotPriceBefore <= Math.rdiv(inAmount, outAmount), \"Benchmark: math problem\");\n\n        emit Swap(msg.sender, inAmount, outAmount, msg.sender);\n\n        _pullToken(inToken, msg.sender, inAmount);\n        _pushToken(outToken, msg.sender, outAmount);\n\n        return (inAmount, spotPriceAfter);\n    }\n\n    /**\n     * @notice join the pool by putting in xytToken and pairTokens\n     * and get back desired amount of lpToken\n     */\n\n    function joinPoolByAll(\n        uint256 outAmountLp,\n        uint256 maxInAmoutXyt,\n        uint256 maxInAmountPair\n    ) external override {\n        uint256 totalLp = totalSupply;\n        uint256 ratio = Math.rdiv(outAmountLp, totalLp);\n        require(ratio != 0, \"Benchmark: math problem\");\n\n        //calc and inject xyt token\n        uint256 balanceToken = reserves[xyt].balance;\n        uint256 inAmount = Math.rmul(ratio, balanceToken);\n        require(inAmount != 0, \"Benchmark: math problem\");\n        require(inAmount <= maxInAmoutXyt, \"Benchmark: beyond amount limit\");\n        reserves[xyt].balance = reserves[xyt].balance.add(inAmount);\n        emit Join(msg.sender, xyt, inAmount);\n        _pullToken(xyt, msg.sender, inAmount);\n\n        //calc and inject pair token\n        balanceToken = reserves[token].balance;\n        inAmount = Math.rmul(ratio, balanceToken);\n        require(inAmount != 0, \"Benchmark: math problem\");\n        require(inAmount <= maxInAmountPair, \"Benchmark: beyond amount limit\");\n        reserves[token].balance = reserves[token].balance.add(inAmount);\n        emit Join(msg.sender, token, inAmount);\n        _pullToken(token, msg.sender, inAmount);\n\n        //mint and push lp token\n        _mintLpToken(outAmountLp);\n        _pushLpToken(msg.sender, outAmountLp);\n        printAcc(msg.sender);\n    }\n\n    function printAcc(address a) internal view {\n        console.log(\"\\t\\t[contract] Details for \", a);\n        console.log(\"\\t\\t\\t[contract] globalIncomeIndex=\", globalIncomeIndex);\n        console.log(\n            \"\\t\\t\\t[contract] underlyingYieldTokenAsset bal of account=\",\n            IERC20(IBenchmarkYieldToken(xyt).underlyingYieldToken()).balanceOf(a)\n        );\n        console.log(\n            \"\\t\\t\\t[contract] underlyingYieldToken bal of amm =\",\n            IERC20(IBenchmarkYieldToken(xyt).underlyingYieldToken()).balanceOf(address(this))\n        );\n        console.log(\n            \"\\t\\t\\t[contract] lastGlobalIncomeIndex of account = \",\n            lastGlobalIncomeIndex[a]\n        );\n    }\n\n    /**\n     * @notice exit the pool by putting in desired amount of lpToken\n     * and get back xytToken and pairToken\n     */\n    function exitPoolByAll(\n        uint256 inAmountLp,\n        uint256 minOutAmountXyt,\n        uint256 minOutAmountPair\n    ) external override {\n        IBenchmarkData data = core.data();\n        uint256 exitFee = data.exitFee();\n        uint256 totalLp = totalSupply;\n        uint256 exitFees = Math.rmul(inAmountLp, exitFee);\n        uint256 InLpAfterExitFee = inAmountLp.sub(exitFee);\n        uint256 ratio = Math.rdiv(InLpAfterExitFee, totalLp);\n        require(ratio != 0, \"Benchmark: math problem\");\n\n        //calc and withdraw xyt token\n        uint256 balanceToken = reserves[xyt].balance;\n        uint256 outAmount = Math.rmul(ratio, balanceToken);\n        require(outAmount != 0, \"Benchmark: math problem\");\n        require(outAmount >= minOutAmountXyt, \"Benchmark: beyond amount limit\");\n        reserves[xyt].balance = reserves[xyt].balance.sub(outAmount);\n        emit Exit(msg.sender, xyt, outAmount);\n        _pushToken(xyt, msg.sender, outAmount);\n\n        //calc and withdraw pair token\n        balanceToken = reserves[token].balance;\n        outAmount = Math.rmul(ratio, balanceToken);\n        require(outAmount != 0, \"Benchmark: math problem\");\n        require(outAmount >= minOutAmountPair, \"Benchmark: beyond amount limit\");\n        reserves[token].balance = reserves[token].balance.sub(outAmount);\n        emit Exit(msg.sender, token, outAmount);\n        _pushToken(token, msg.sender, outAmount);\n\n        //let's deal with lp last\n        _pullLpToken(msg.sender, inAmountLp);\n        _pushLpToken(factory, exitFees);\n        _burnLpToken(InLpAfterExitFee);\n    }\n\n    function joinPoolSingleToken(\n        address inToken,\n        uint256 inAmount,\n        uint256 minOutAmountLp\n    ) external override returns (uint256 outAmountLp) {\n        IBenchmarkData data = core.data();\n        TokenReserve storage inTokenReserve = reserves[inToken];\n        uint256 totalLp = totalSupply;\n        uint256 totalWeight = reserves[xyt].weight.add(reserves[token].weight);\n\n        //calc out amount of lp token\n        outAmountLp = _calcOutAmountLp(\n            inAmount,\n            inTokenReserve,\n            data.swapFee(),\n            totalLp,\n            totalWeight\n        );\n        require(outAmountLp >= minOutAmountLp, \"Benchmark: bad lp out amount\");\n\n        //update reserves and operate underlying lp and intoken\n        inTokenReserve.balance = inTokenReserve.balance.add(inAmount);\n\n        emit Join(msg.sender, inToken, inAmount);\n\n        _mintLpToken(outAmountLp);\n        _pushLpToken(msg.sender, outAmountLp);\n        _pullToken(inToken, msg.sender, inAmount);\n\n        return outAmountLp;\n    }\n\n    function exitPoolSingleToken(\n        address outToken,\n        uint256 inAmountLp,\n        uint256 minOutAmountToken\n    ) external override returns (uint256 outAmountToken) {\n        IBenchmarkData data = core.data();\n        TokenReserve storage outTokenReserve = reserves[outToken];\n        uint256 exitFee = data.exitFee();\n        uint256 totalLp = totalSupply;\n        uint256 totalWeight = reserves[xyt].weight.add(reserves[token].weight);\n\n        outAmountToken = _calcOutAmountToken(\n            data,\n            outTokenReserve,\n            totalLp,\n            totalWeight,\n            inAmountLp\n        );\n        require(outAmountToken >= minOutAmountToken, \"Benchmark: bad token out amount\");\n\n        //update reserves and operate underlying lp and outtoken\n        outTokenReserve.balance = outTokenReserve.balance.sub(outAmountToken);\n\n        uint256 exitFees = Math.rmul(inAmountLp, data.exitFee());\n\n        emit Exit(msg.sender, outToken, outAmountToken);\n\n        _pullLpToken(msg.sender, inAmountLp);\n        _burnLpToken(inAmountLp.sub(exitFees));\n        _pushLpToken(factory, exitFee);\n        _pushToken(outToken, msg.sender, outAmountToken);\n\n        return outAmountToken;\n    }\n\n    function interestDistribute(address lp) internal returns (uint256 interestReturn) {}\n\n    function _calcSpotPrice(\n        TokenReserve memory inTokenReserve,\n        TokenReserve memory outTokenReserve,\n        uint256 swapFee\n    ) internal pure returns (uint256 spot) {\n        uint256 numer = Math.rdiv(inTokenReserve.balance, inTokenReserve.weight);\n        uint256 denom = Math.rdiv(outTokenReserve.balance, outTokenReserve.weight);\n        uint256 ratio = Math.rdiv(numer, denom);\n        uint256 scale = Math.rdiv(Math.RAY, Math.RAY.sub(swapFee));\n\n        spot = Math.rmul(ratio, scale);\n    }\n\n    function _calcOutAmount(\n        TokenReserve memory inTokenReserve,\n        TokenReserve memory outTokenReserve,\n        uint256 swapFee,\n        uint256 inAmount\n    ) internal pure returns (uint256 outAmount) {\n        uint256 weightRatio = Math.rdiv(inTokenReserve.weight, outTokenReserve.weight);\n        uint256 adjustedIn = Math.RAY.sub(swapFee);\n        adjustedIn = Math.rmul(inAmount, adjustedIn);\n        uint256 y = Math.rdiv(inTokenReserve.balance, inTokenReserve.balance.add(adjustedIn));\n        uint256 foo = Math.rpow(y, weightRatio);\n        uint256 bar = Math.RAY.sub(foo);\n\n        outAmount = Math.rmul(outTokenReserve.balance, bar);\n    }\n\n    function _calcInAmount(\n        TokenReserve memory inTokenReserve,\n        TokenReserve memory outTokenReserve,\n        uint256 swapFee,\n        uint256 outAmount\n    ) internal pure returns (uint256 inAmount) {\n        uint256 weightRatio = Math.rdiv(outTokenReserve.weight, inTokenReserve.weight);\n        uint256 diff = outTokenReserve.balance.sub(outAmount);\n        uint256 y = Math.rdiv(outTokenReserve.balance, diff);\n        uint256 foo = Math.rpow(y, weightRatio);\n\n        foo = foo.sub(Math.RAY);\n        inAmount = Math.RAY.sub(swapFee);\n        inAmount = Math.rdiv(Math.rmul(inTokenReserve.balance, foo), inAmount);\n    }\n\n    function _calcOutAmountLp(\n        uint256 inAmount,\n        TokenReserve memory inTokenReserve,\n        uint256 swapFee,\n        uint256 totalSupplyLp,\n        uint256 totalWeight\n    ) internal pure returns (uint256 outAmountLp) {\n        uint256 nWeight = Math.rdiv(inTokenReserve.weight, totalWeight);\n        uint256 feePortion = Math.rmul(Math.RAY.sub(nWeight), swapFee);\n        uint256 inAmoutAfterFee = Math.rmul(inAmount, Math.RAY.sub(feePortion));\n\n        uint256 inBalanceUpdated = inTokenReserve.balance.add(inAmoutAfterFee);\n        uint256 inTokenRatio = Math.rdiv(inBalanceUpdated, inTokenReserve.balance);\n\n        uint256 lpTokenRatio = Math.rpow(inTokenRatio, nWeight);\n        uint256 totalSupplyLpUpdated = Math.rmul(lpTokenRatio, totalSupplyLp);\n        outAmountLp = totalSupplyLpUpdated.sub(totalSupplyLp);\n        return outAmountLp;\n    }\n\n    function _calcOutAmountToken(\n        IBenchmarkData data,\n        TokenReserve memory outTokenReserve,\n        uint256 totalSupplyLp,\n        uint256 totalWeight,\n        uint256 inAmountLp\n    ) internal view returns (uint256 outAmountToken) {\n        uint256 nWeight = Math.rdiv(outTokenReserve.weight, totalWeight);\n        uint256 inAmountLpAfterExitFee = Math.rmul(inAmountLp, Math.RAY.sub(data.exitFee()));\n        uint256 totalSupplyLpUpdated = totalSupplyLp.sub(inAmountLpAfterExitFee);\n        uint256 lpRatio = Math.rdiv(totalSupplyLpUpdated, totalSupplyLp);\n\n        uint256 outTokenRatio = Math.rpow(lpRatio, Math.rdiv(Math.RAY, nWeight));\n        uint256 outTokenBalanceUpdated = Math.rmul(outTokenRatio, outTokenReserve.balance);\n\n        uint256 outAmountTOkenBeforeSwapFee = outTokenReserve.balance.sub(outTokenBalanceUpdated);\n\n        uint256 feePortion = Math.rmul(Math.RAY.sub(nWeight), data.swapFee());\n        outAmountToken = Math.rmul(outAmountTOkenBeforeSwapFee, Math.RAY.sub(feePortion));\n        return outAmountToken;\n    }\n\n    function _pullToken(\n        address tokenAddr,\n        address fromAddr,\n        uint256 amountToPull\n    ) internal {\n        /* tmpAddress = fromAddress; */\n        IERC20(tokenAddr).safeTransferFrom(fromAddr, address(this), amountToPull);\n    }\n\n    function _pushToken(\n        address tokenAddr,\n        address toAddr,\n        uint256 amountToPush\n    ) internal {\n        IERC20(tokenAddr).safeTransfer(toAddr, amountToPush);\n    }\n\n    function _pullLpToken(address from, uint256 amount) internal {\n        _transfer(from, address(this), amount);\n    }\n\n    function _pushLpToken(address to, uint256 amount) internal {\n        _transfer(address(this), to, amount);\n    }\n\n    function _mintLpToken(uint256 amount) internal {\n        _mint(address(this), amount);\n    }\n\n    function _burnLpToken(uint256 amount) internal {\n        _burn(address(this), amount);\n    }\n\n    function _updateWeight() internal {\n        uint256 currentTime = block.timestamp;\n        uint256 endTime = IBenchmarkYieldToken(xyt).expiry();\n        uint256 duration = 6 * 3600 * 24 * 30;\n\n        TokenReserve storage xytReserve = reserves[xyt];\n        TokenReserve storage tokenReserve = reserves[token];\n\n        uint256 xytWeight = xytReserve.weight;\n        uint256 tokenWeight = tokenReserve.weight;\n        console.log(\"\\tendTime,\", endTime);\n        console.log(\"\\tcurrentTime,\", currentTime);\n        console.log(\"\\tduration,\", duration);\n\n        require((endTime - currentTime) <= duration, \"Benchmark: wrong duration\");\n\n        uint256 timeToMature = Math.rdiv((endTime - currentTime) * Math.RAY, duration * Math.RAY);\n        uint256 priceNow =\n            Math.rdiv(\n                Math.ln(Math.rmul(Math.PI, timeToMature).add(Math.RAY), Math.RAY),\n                Math.ln(Math.PI_PLUSONE, Math.RAY)\n            );\n        uint256 r = Math.rdiv(priceNow, priceLast);\n        require(Math.RAY >= r, \"Benchmark: wrong r value\");\n\n        uint256 thetaNumerator = Math.rmul(Math.rmul(xytWeight, tokenWeight), Math.RAY.sub(r));\n        uint256 thetaDenominator = Math.rmul(r, xytWeight).add(tokenWeight);\n\n        uint256 theta = Math.rdiv(thetaNumerator, thetaDenominator);\n\n        uint256 xytWeightUpdated = xytWeight.sub(theta);\n        uint256 tokenWeightUpdated = tokenWeight.add(theta);\n\n        reserves[xyt].weight = xytWeightUpdated;\n        reserves[token].weight = tokenWeightUpdated;\n        priceLast = priceNow;\n\n        emit Shift(xytWeight, tokenWeight, xytWeightUpdated, tokenWeightUpdated);\n    }\n\n    function _curveShift() internal {\n        if (block.number > blockNumLast) {\n            _updateWeight();\n            blockNumLast = block.number;\n        }\n    }\n\n    // sends out any due interests to msg.sender if he's an LP holder\n    // this should be called before any functions that change someone's LPs\n    function _settleLpInterests(address account) internal {\n        _updateGlobalIncomeIndex();\n        if (lastGlobalIncomeIndex[account] == 0) {\n            lastGlobalIncomeIndex[account] = globalIncomeIndex;\n            return;\n        }\n\n        uint256 dueInterests =\n            balanceOf[account].mul(globalIncomeIndex - lastGlobalIncomeIndex[account]).div(\n                GLOBAL_INCOME_INDEX_MULTIPLIER\n            );\n        /* console.log(\"\\t[contract] dueInterests in _settleLpInterests = \", dueInterests, account); */\n\n        lastGlobalIncomeIndex[account] = globalIncomeIndex;\n        if (dueInterests == 0) return;\n        IERC20(IBenchmarkYieldToken(xyt).underlyingYieldToken()).safeTransfer(\n            account,\n            dueInterests\n        );\n\n        console.log(\"Settled LP interests for \", account);\n        printAcc(account);\n    }\n\n    // this function should be called whenver the total amount of LP changes\n    //\n    function _updateGlobalIncomeIndex() internal {\n        uint256 currentUnderlyingYieldTokenBalance =\n            IERC20(IBenchmarkYieldToken(xyt).underlyingYieldToken()).balanceOf(address(this));\n        uint256 interestsEarned =\n            currentUnderlyingYieldTokenBalance - lastUnderlyingYieldTokenBalance;\n        lastUnderlyingYieldTokenBalance = currentUnderlyingYieldTokenBalance;\n\n        globalIncomeIndex = globalIncomeIndex.add(\n            interestsEarned.mul(GLOBAL_INCOME_INDEX_MULTIPLIER).div(totalSupply)\n        );\n    }\n\n    function _beforeTokenTransfer(address from, address to) internal override {\n        _settleLpInterests(from);\n        _settleLpInterests(to);\n    }\n}\n"
    },
    "contracts/interfaces/IBenchmarkMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport \"./IBenchmark.sol\";\nimport \"./IBenchmarkBaseToken.sol\";\nimport {Utils} from \"../libraries/BenchmarkLibrary.sol\";\n\ninterface IBenchmarkMarket is IBenchmarkBaseToken {\n    /* ========== EVENTS ========== */\n\n    /**\n     * @notice Emitted when a swap happens on the market.\n     * @param trader The address of msg.sender.\n     * @param srcAmount The source amount being traded.\n     * @param destAmount The destination amount received.\n     * @param destination The destination addressed where the swap funds is sent to.\n     **/\n    event Swap(\n        address indexed trader,\n        uint256 srcAmount,\n        uint256 destAmount,\n        address indexed destination\n    );\n\n    event Join(address indexed lp, address indexed token, uint256 amount);\n    event Exit(address indexed lp, address indexed token, uint256 amount);\n\n    event Shift(\n        uint256 xytWeightOld,\n        uint256 tokenWeightOld,\n        uint256 xytWeightNew,\n        uint256 tokenWeightNew\n    );\n\n    /* ========== POOL MANAGEMENT ========== */\n\n    // function setPoolRatio(\n    //     address xytToken,\n    //     uint256 denomXYToken,\n    //     address pairToken,\n    //     uint256 denomPairToken\n    // ) external;\n\n    /* ========== TRADE ========== */\n\n    function spotPrice(address inToken, address outToken) external returns (uint256 spot);\n\n    function swapAmountIn(\n        uint256 inAmount,\n        address inToken,\n        address outToken,\n        uint256 minOutAmount,\n        uint256 maxPrice\n    ) external returns (uint256 outAmount, uint256 spotPriceAfter);\n\n    function swapAmountOut(\n        address inToken,\n        uint256 maxInAmount,\n        address outToken,\n        uint256 outAmount,\n        uint256 maxPrice\n    ) external returns (uint256 inAmount, uint256 spotPriceAfter);\n\n    /* ========== LP ========== */\n\n    function joinPoolByAll(\n        uint256 outAmountLp,\n        uint256 maxInAmoutXyt,\n        uint256 maxInAmountPair\n    ) external;\n\n    function exitPoolByAll(\n        uint256 inAmountLp,\n        uint256 minOutAmountXyt,\n        uint256 minOutAmountPair\n    ) external;\n\n    function joinPoolSingleToken(\n        address inToken,\n        uint256 inAmount,\n        uint256 minOutAmountLp\n    ) external returns (uint256 outAmountLp);\n\n    function exitPoolSingleToken(\n        address outToken,\n        uint256 inAmountLp,\n        uint256 minOutAmountToken\n    ) external returns (uint256 outAmountToken);\n\n    //function interestDistribute(address lp)  returns (uint interestReturn);\n\n    /* ========== CURVE SHIFTING ========== */\n\n    //function shiftWeight(address xytToken, address pairToken) internal;\n\n    //function shiftCurve(address xytToken, address pairToken) internal;\n\n    /* ========== VIEW ========== */\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 xytReserves,\n            uint112 tokenReserves,\n            uint32 lastBlockTimestamp\n        );\n\n    /**\n     * @notice Gets a reference to the Benchmark core contract.\n     * @return Returns the core contract reference.\n     **/\n    function core() external view returns (IBenchmark);\n\n    /**\n     * @dev Returns the address of the BenchmarkMarketFactory contract address.\n     * @return Returns the factory's address.\n     **/\n    function factory() external view returns (address);\n\n    /**\n     * @notice Gets the forge address where the XYT was minted.\n     * @return Returns the forge address.\n     **/\n    function forge() external view returns (address);\n\n    function minLiquidity() external pure returns (uint256);\n\n    function token() external view returns (address);\n\n    function xyt() external view returns (address);\n}\n"
    },
    "contracts/tokens/BenchmarkBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBenchmarkBaseToken.sol\";\n\n/**\n *   @title BenchmarkBaseToken\n *   @dev The contract implements the standard ERC20 functions, plus some\n *        Benchmark specific fields and functions, namely:\n *          - expiry\n *\n *        This abstract contract is inherited by BenchmarkFutureYieldToken\n *        and BenchmarkOwnershipToken contracts.\n **/\nabstract contract BenchmarkBaseToken is IBenchmarkBaseToken {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n    mapping(address => uint256) public override balanceOf;\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    uint256 public override expiry;\n    uint256 public override totalSupply;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        expiry = _expiry;\n    }\n\n    /**\n     * @dev Sets amount as the allowance of spender over the owner's tokens.\n     * @param spender The address spending the owner's tokens.\n     * @param amount The amount allowed to be spent.\n     * @return Returns true if approval has succeeded, otherwise false.\n     **/\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev Burns OT or XYT tokens from account, reducting the total supply.\n     * @param account The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    function burn(address account, uint256 amount) public override {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Decreases the allowance granted to spender by the caller.\n     * @param spender The address to reduce the allowance from.\n     * @param subtractedValue The amount allowance to subtract.\n     * @return Returns true if allowance has decreased, otherwise false.\n     **/\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        override\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender].sub(subtractedValue, \"Benchmark: allowance < 0\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Increases the allowance granted to spender by the caller.\n     * @param spender The address to increase the allowance from.\n     * @param addedValue The amount allowance to add.\n     * @return returns true if allowance has increased, otherwise false\n     **/\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Mints new OT or XYT tokens for account, increasing the total supply.\n     * @param account The address to send the minted tokens.\n     * @param amount The amount to be minted.\n     **/\n    function mint(address account, uint256 amount) public override {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev The amount of tokens to transfer to recipient.\n     * @param recipient The address receiving the tokens.\n     * @param amount The amount to be transferred.\n     * @return Returns true if transfer has succeeded, otherwise false.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev The amount of tokens to transfer to recipient from the sender's address.\n     * @param sender The address sending the tokens.\n     * @param recipient The address receiving the tokens.\n     * @param amount The amount to be transferred.\n     * @return Returns true if transferFrom has succeeded, otherwise false.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            allowance[sender][msg.sender].sub(amount, \"Benchmark: transfer > allowance\")\n        );\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"Benchmark: owner zero address\");\n        require(spender != address(0), \"Benchmark: spender zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"Benchmark: mint to zero address\");\n\n        totalSupply = totalSupply.add(amount);\n        balanceOf[account] = balanceOf[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"Benchmark: burn to zero address\");\n\n        balanceOf[account] = balanceOf[account].sub(amount, \"Benchmark: burn > balance\");\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"Benchmark: sender zero address\");\n        require(receiver != address(0), \"Benchmark: receiver zero address\");\n\n        _beforeTokenTransfer(sender, receiver);\n\n        balanceOf[sender] = balanceOf[sender].sub(amount, \"Benchmark: transfer > balance\");\n        balanceOf[receiver] = balanceOf[receiver].add(amount);\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function _beforeTokenTransfer(address from, address to) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/BenchmarkMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport {Factory} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"./BenchmarkMarket.sol\";\nimport \"../interfaces/IBenchmark.sol\";\nimport \"../interfaces/IBenchmarkData.sol\";\nimport \"../interfaces/IBenchmarkMarketFactory.sol\";\nimport \"../interfaces/IBenchmarkYieldToken.sol\";\nimport \"../periphery/Permissions.sol\";\n\ncontract BenchmarkMarketFactory is IBenchmarkMarketFactory, Permissions {\n    IBenchmark public override core;\n\n    constructor(address _governance, address _initializer) Permissions(_governance, _initializer) {}\n\n    function initialize(IBenchmark _core) external {\n        require(msg.sender == initializer, \"Benchmark: forbidden\");\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n\n        initializer = address(0);\n        core = _core;\n    }\n\n    function createMarket(\n        bytes32 _forgeId,\n        address _xyt,\n        address _token,\n        uint256 _expiry\n    ) external override initialized returns (address market) {\n        require(_xyt != _token, \"Benchmark: similar tokens\");\n        require(_xyt != address(0) && _token != address(0), \"Benchmark: zero address\");\n\n        IBenchmarkData data = core.data();\n        address forgeAddress = data.getForgeAddress(_forgeId);\n\n        require(\n            data.getMarket(_forgeId, _xyt, _token) == address(0),\n            \"Benchmark: market already exists\"\n        );\n        require(data.isValidXYT(_xyt), \"Benchmark: not xyt\");\n\n        market = Factory.createContract(\n            type(BenchmarkMarket).creationCode,\n            abi.encodePacked(msg.sender, core, forgeAddress, _xyt, _token, _expiry),\n            abi.encode(msg.sender, core, forgeAddress, _xyt, _token, _expiry)\n        );\n        data.storeMarket(_forgeId, _xyt, _token, market);\n        data.addMarket(market);\n\n        emit MarketCreated(_xyt, _token, market);\n    }\n\n    function setCore(IBenchmark _core) public override onlyGovernance {\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n\n        core = _core;\n        emit CoreSet(address(_core));\n    }\n}\n"
    },
    "contracts/core/BenchmarkTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBenchmarkTreasury.sol\";\nimport \"../periphery/Permissions.sol\";\n\ncontract BenchmarkTreasury is IBenchmarkTreasury, Permissions {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public override fundToken;\n    uint256 public constant MAX_FUND_PERCENTAGE = 1500; // 15%\n    uint256 public constant PERCENTAGE_PRECISION = 10000; // 100%\n    uint256 public fundPercentage = 500; // 5%\n\n    constructor(address _governance, address _initializer) Permissions(_governance, _initializer) {\n        initializer = msg.sender;\n    }\n\n    function initialize(IERC20 _fundToken) external {\n        require(msg.sender == initializer, \"Benchmark: forbidden\");\n        require(address(_fundToken) != address(0), \"Benchmark: zero address\");\n\n        initializer = address(0);\n        fundToken = _fundToken;\n    }\n\n    function setFundPercentage(uint256 _fundPercentage) external override onlyGovernance {\n        require(_fundPercentage <= MAX_FUND_PERCENTAGE, \"Benchmark: exceeded max%\");\n        fundPercentage = _fundPercentage;\n    }\n\n    function deposit(IERC20 token, uint256 amount) external override {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount, address withdrawAddress) external override onlyGovernance {\n        require(balanceOf(fundToken) >= amount, \"Benchmark: insufficient funds\");\n        fundToken.safeTransfer(withdrawAddress, amount);\n    }\n\n    function balanceOf(IERC20 token) public view override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IBenchmarkTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBenchmarkTreasury {\n    function setFundPercentage(uint256 _fundPercentage) external;\n\n    function deposit(IERC20 token, uint256 amount) external;\n\n    function withdraw(uint256 amount, address withdrawAddress) external;\n\n    function balanceOf(IERC20 token) external view returns (uint256);\n\n    function fundToken() external view returns (IERC20);\n}\n"
    },
    "contracts/mock/MockTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../core/BenchmarkTreasury.sol\";\n\ncontract MockTreasury is BenchmarkTreasury {\n    constructor() BenchmarkTreasury(0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa,0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa) {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/periphery/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    /// @notice An event emitted when the timelock admin changes\n    event NewAdmin(address indexed newAdmin);\n    /// @notice An event emitted when a new admin is staged in the timelock\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    /// @notice An event emitted when a queued transaction is cancelled\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    /// @notice An event emitted when a queued transaction is executed\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    /// @notice An event emitted when a new transaction is queued\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /// @notice the length of time after the delay has passed that a transaction can be executed\n    uint256 public constant GRACE_PERIOD = 14 days;\n    /// @notice the minimum length of the timelock delay\n    uint256 public constant MINIMUM_DELAY = 12 hours + 2 * 60 * 15; // have to be present for 2 rebases\n    /// @notice the maximum length of the timelock delay\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n    bool public admin_initialized;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() {\n        /* require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\"); */\n\n        admin = msg.sender;\n        delay = MINIMUM_DELAY;\n        admin_initialized = false;\n    }\n\n    receive() external payable {}\n\n    /**\n    @notice sets the delay\n    @param delay_ the new delay\n     */\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    /// @notice sets the new admin address\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    /**\n    @notice queues a new pendingAdmin\n    @param pendingAdmin_ the new pendingAdmin address\n     */\n    function setPendingAdmin(address pendingAdmin_) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(\n                msg.sender == address(this),\n                \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n            );\n        } else {\n            admin_initialized = true;\n        }\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        // timelock not enforced prior to updating the admin. This should occur on\n        // deployment.\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (admin_initialized) {\n            require(\n                queuedTransactions[txHash],\n                \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n            );\n            require(\n                getBlockTimestamp() >= eta,\n                \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n            );\n            require(\n                getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n                \"Timelock::executeTransaction: Transaction is stale.\"\n            );\n\n            queuedTransactions[txHash] = false;\n        }\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/core/BenchmarkGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/IBenchmarkGovernance.sol\";\nimport \"../interfaces/IBMK.sol\";\nimport \"../interfaces/ITimelock.sol\";\n\ncontract BenchmarkGovernance is IBenchmarkGovernance {\n    using SafeMath for uint256;\n\n    /**\n     * @notice The name of this contract\n     **/\n    string public constant name = \"Benchmark Governance\";\n\n    /**\n     * @notice The number of votes in support of a proposal required in order\n     * for a quorum to be reached and for a vote to succeed\n     */\n    function quorumVotes() public pure returns (uint256) {\n        return 400000e18;\n    }\n\n    /**\n     * @notice The number of votes required in order for a voter to become a proposer\n     */\n    function proposalThreshold() public pure returns (uint256) {\n        return 100000e18;\n    }\n\n    /**\n     * @notice The maximum number of actions that can be included in a proposal\n     */\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10;\n    }\n\n    /**\n     * @notice The delay before voting on a proposal may take place, once proposed\n     */\n    function votingDelay() public pure returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice The duration of voting on a proposal, in blocks\n     */\n    function votingPeriod() public pure returns (uint256) {\n        return 17280;\n    }\n\n    /**\n     * @notice The address of the Timelock contract\n     */\n    ITimelock public timelock;\n\n    /**\n     * @notice The address of the Benchmark governance token\n     */\n    IBMK public bmk;\n\n    /**\n     * @notice The address of the Governor Guardian\n     */\n    address public guardian;\n\n    /**\n     * @notice The total number of proposals\n     */\n    uint256 public proposalCount;\n\n    struct Proposal {\n        uint256 id; // Unique id for looking up a proposal\n        address proposer; // Creator of the proposal\n        uint256 eta; // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        address[] targets; // The ordered list of target addresses for calls to be made\n        uint256[] values; // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        string[] signatures; // The ordered list of function signatures to be called\n        bytes[] calldatas; // The ordered list of calldata to be passed to each call\n        uint256 startBlock; // The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 endBlock; // The block at which voting ends: votes must be cast prior to this block\n        uint256 forVotes; // Current number of votes in favor of this proposal\n        uint256 againstVotes; // Current number of votes in opposition to this proposal\n        bool canceled; // Flag marking whether the proposal has been canceled\n        bool executed; // Flag marking whether the proposal has been executed\n        mapping(address => Receipt) receipts; // Receipts of ballots for the entire set of voters\n    }\n\n    /**\n     * @notice Ballot receipt record for a voter\n     **/\n    struct Receipt {\n        bool hasVoted; // Whether or not a vote has been cast\n        bool support; // Whether or not the voter supports the proposal\n        uint96 votes; // The number of votes the voter had, which were cast\n    }\n\n    /**\n     * @notice Possible states that a proposal may be in\n     **/\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /**\n     * @notice The official record of all proposals ever proposed\n     **/\n    mapping(uint256 => Proposal) public proposals;\n\n    /**\n     * @notice The latest proposal for each proposer\n     **/\n    mapping(address => uint256) public latestProposalIds;\n\n    /**\n     * @notice The EIP-712 typehash for the contract's domain\n     **/\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /**\n     * @notice The EIP-712 typehash for the ballot struct used by the contract\n     **/\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /**\n     * @notice An event emitted when a new proposal is created\n     **/\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @notice An event emitted when a vote has been cast on a proposal\n     **/\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /**\n     * @notice An event emitted when a proposal has been canceled\n     **/\n    event ProposalCanceled(uint256 id);\n\n    /**\n     * @notice An event emitted when a proposal has been queued in the Timelock\n     **/\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /**\n     * @notice An event emitted when a proposal has been executed in the Timelock\n     **/\n    event ProposalExecuted(uint256 id);\n\n    constructor(\n        IBMK _bmk,\n        ITimelock _timelock,\n        address _guardian\n    ) {\n        bmk = _bmk;\n        timelock = _timelock;\n        guardian = _guardian;\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        require(\n            bmk.getPriorVotes(msg.sender, block.number.sub(1)) > proposalThreshold(),\n            \"Benchmark: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"Benchmark: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Benchmark: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"Benchmark: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"Benchmark: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"Benchmark: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 startBlock = block.number.add(votingDelay());\n        uint256 endBlock = startBlock.add(votingPeriod());\n\n        proposalCount++;\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposal.id;\n    }\n\n    function queue(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"Benchmark: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp.add(timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(target, value, signature, data, eta))\n            ),\n            \"Benchmark: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function execute(uint256 proposalId) public payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"Benchmark: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    function cancel(uint256 proposalId) public {\n        ProposalState currentState = state(proposalId);\n        require(\n            currentState != ProposalState.Executed,\n            \"Benchmark: cannot cancel executed proposal\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        require(\n            msg.sender == guardian ||\n                bmk.getPriorVotes(proposal.proposer, block.number.sub(1)) < proposalThreshold(),\n            \"Benchmark: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"Benchmark: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (\n            proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()\n        ) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta.add(timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Benchmark: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(state(proposalId) == ProposalState.Active, \"Benchmark: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"Benchmark::_castVote: voter already voted\");\n        uint96 votes = bmk.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = proposal.forVotes.add(votes);\n        } else {\n            proposal.againstVotes = proposal.againstVotes.add(votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"Benchmark: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"Benchmark: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"Benchmark: sender must be gov guardian\");\n        timelock.queueTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"Benchmark: sender must be gov guardian\");\n        timelock.executeTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/interfaces/IBenchmarkGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\ninterface IBenchmarkGovernance {}\n"
    },
    "contracts/interfaces/IBMK.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\ninterface IBMK {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.7.0;\n\ninterface ITimelock {\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external;\n\n    function delay() external returns (uint256);\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external payable returns (bytes calldata);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function queuedTransactions(bytes32 txn) external returns (bool);\n}\n"
    },
    "contracts/mock/MockGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../core/BenchmarkGovernance.sol\";\npragma experimental ABIEncoderV2;\n\ncontract MockGovernance is BenchmarkGovernance {\n    constructor(\n        IBMK _bmk,\n        ITimelock _timelock,\n        address _guardian\n    ) BenchmarkGovernance(_bmk, _timelock, _guardian) {}\n}\n"
    },
    "contracts/tokens/BMK.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IBMK.sol\";\n\ncontract BMK is IBMK {\n    string public constant name = \"Benchmark\";\n    string public constant symbol = \"BMK\";\n    uint8 public constant decimals = 18;\n    uint256 public constant totalSupply = 10000000e18; // 10 million Comp\n    mapping(address => mapping(address => uint96)) internal allowances;\n    mapping(address => uint96) internal balances;\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) {\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     **/\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     **/\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Benchmark: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = safe96(rawAmount, \"Benchmark::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Benchmark::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance =\n                sub96(\n                    spenderAllowance,\n                    amount,\n                    \"Benchmark::transferFrom: transfer amount exceeds spender allowance\"\n                );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Benchmark: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Benchmark: invalid nonce\");\n        require(block.timestamp <= expiry, \"Benchmark: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        override\n        returns (uint96)\n    {\n        require(blockNumber < block.number, \"Benchmark: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Benchmark: cannot transfer from the zero address\");\n        require(dst != address(0), \"Benchmark: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Benchmark: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Benchmark: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Benchmark: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Benchmark: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, \"Benchmark: block number exceeds 32 bits\");\n\n        if (\n            nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n        ) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/tokens/BenchmarkOwnershipToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"./BenchmarkBaseToken.sol\";\nimport \"../interfaces/IBenchmarkYieldToken.sol\";\n\ncontract BenchmarkOwnershipToken is BenchmarkBaseToken, IBenchmarkYieldToken {\n    address public override forge;\n    address public override underlyingAsset;\n    address public override underlyingYieldToken;\n\n    constructor(\n        address _underlyingAsset,\n        address _underlyingYieldToken,\n        string memory _name,\n        string memory _symbol,\n        uint8 _underlyingYieldTokenDecimals,\n        uint256 _expiry\n    ) BenchmarkBaseToken(_name, _symbol, _underlyingYieldTokenDecimals, _expiry) {\n        forge = msg.sender;\n        underlyingAsset = _underlyingAsset;\n        underlyingYieldToken = _underlyingYieldToken;\n    }\n}\n"
    },
    "contracts/tokens/BenchmarkFutureYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"./BenchmarkBaseToken.sol\";\nimport \"../interfaces/IBenchmarkForge.sol\";\nimport \"../interfaces/IBenchmarkYieldToken.sol\";\n\ncontract BenchmarkFutureYieldToken is BenchmarkBaseToken, IBenchmarkYieldToken {\n    address public override forge;\n    address public override underlyingAsset;\n    address public override underlyingYieldToken;\n    address public ot;\n    mapping(address => uint256) public lastNormalisedIncome;\n\n    constructor(\n        address _ot,\n        address _underlyingAsset,\n        address _underlyingYieldToken,\n        string memory _name,\n        string memory _symbol,\n        uint8 _underlyingYieldTokenDecimals,\n        uint256 _expiry\n    ) BenchmarkBaseToken(_name, _symbol, _underlyingYieldTokenDecimals, _expiry) {\n        forge = msg.sender;\n        ot = _ot;\n        underlyingAsset = _underlyingAsset;\n        underlyingYieldToken = _underlyingYieldToken;\n    }\n\n    function _beforeTokenTransfer(address from, address to) internal override {\n        IBenchmarkForge(forge).redeemDueInterestsBeforeTransfer(underlyingAsset, expiry, from);\n        IBenchmarkForge(forge).redeemDueInterestsBeforeTransfer(underlyingAsset, expiry, to);\n    }\n}\n"
    },
    "contracts/core/BenchmarkAaveForge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Factory, Utils} from \"../libraries/BenchmarkLibrary.sol\";\nimport \"../interfaces/IAaveLendingPoolCore.sol\";\nimport \"../interfaces/IBenchmarkBaseToken.sol\";\nimport \"../interfaces/IBenchmarkData.sol\";\nimport \"../interfaces/IBenchmarkForge.sol\";\nimport \"../tokens/BenchmarkFutureYieldToken.sol\";\nimport \"../tokens/BenchmarkOwnershipToken.sol\";\nimport \"hardhat/console.sol\";\n\ncontract BenchmarkAaveForge is IBenchmarkForge, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Utils for string;\n\n    struct BenchmarkTokens {\n        IBenchmarkYieldToken xyt;\n        IBenchmarkYieldToken ot;\n    }\n\n    IBenchmark public immutable override core;\n    IAaveLendingPoolCore public immutable aaveLendingPoolCore;\n    bytes32 public immutable override forgeId;\n\n    mapping(address => mapping(uint256 => uint256)) public lastNormalisedIncomeBeforeExpiry;\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public lastNormalisedIncome; //lastNormalisedIncome[underlyingAsset][expiry][account]\n\n    string private constant OT = \"OT-Aave\";\n    string private constant XYT = \"XYT-Aave\";\n\n    constructor(\n        IBenchmark _core,\n        IAaveLendingPoolCore _aaveLendingPoolCore,\n        bytes32 _forgeId\n    ) {\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n        require(address(_aaveLendingPoolCore) != address(0), \"Benchmark: zero address\");\n        require(_forgeId != 0x0, \"Benchmark: zero bytes\");\n\n        core = _core;\n        aaveLendingPoolCore = _aaveLendingPoolCore;\n        forgeId = _forgeId;\n    }\n\n    modifier onlyCore() {\n        require(msg.sender == address(core), \"Benchmark: only core\");\n        _;\n    }\n\n    modifier onlyXYT(address _underlyingAsset, uint256 _expiry) {\n        IBenchmarkData data = core.data();\n        require(\n            msg.sender == address(data.xytTokens(forgeId, _underlyingAsset, _expiry)),\n            \"Benchmark: only XYT\"\n        );\n        _;\n    }\n\n    function newYieldContracts(address _underlyingAsset, uint256 _expiry)\n        public\n        override\n        returns (address ot, address xyt)\n    {\n        address aToken = aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset);\n        uint8 aTokenDecimals = IBenchmarkBaseToken(aToken).decimals();\n\n        string memory otName = OT.concat(IBenchmarkBaseToken(aToken).name(), \" \");\n        string memory otSymbol = OT.concat(IBenchmarkBaseToken(aToken).symbol(), \"-\");\n        string memory xytName = XYT.concat(IBenchmarkBaseToken(aToken).name(), \" \");\n        string memory xytSymbol = XYT.concat(IBenchmarkBaseToken(aToken).symbol(), \"-\");\n\n        ot = _forgeOwnershipToken(\n            _underlyingAsset,\n            otName.concat(_expiry, \" \"),\n            otSymbol.concat(_expiry, \"-\"),\n            aTokenDecimals,\n            _expiry\n        );\n        xyt = _forgeFutureYieldToken(\n            _underlyingAsset,\n            ot,\n            xytName.concat(_expiry, \" \"),\n            xytSymbol.concat(_expiry, \"-\"),\n            aTokenDecimals,\n            _expiry\n        );\n\n        IBenchmarkData data = core.data();\n        data.storeTokens(forgeId, ot, xyt, _underlyingAsset, _expiry);\n\n        emit NewYieldContracts(ot, xyt, _expiry);\n    }\n\n    function redeemDueInterests(\n        address _msgSender,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) public override returns (uint256 interests) {\n        BenchmarkTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        return _settleDueInterests(tokens, _underlyingAsset, _expiry, _msgSender);\n    }\n\n    function redeemDueInterestsBeforeTransfer(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _account\n    ) public override onlyXYT(_underlyingAsset, _expiry) returns (uint256 interests) {\n        // console.log(\"[contract] [Forge] Redeeming due interests for account \", _account);\n        BenchmarkTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        return _settleDueInterests(tokens, _underlyingAsset, _expiry, _account);\n    }\n\n    function redeemAfterExpiry(\n        address _msgSender,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _to\n    ) public override returns (uint256 redeemedAmount) {\n        require(block.timestamp > _expiry, \"Benchmark: must be after expiry\");\n\n        IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n        BenchmarkTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        redeemedAmount = tokens.ot.balanceOf(_msgSender);\n\n        aToken.transfer(_to, redeemedAmount);\n        uint256 currentNormalizedIncome =\n            aaveLendingPoolCore.getReserveNormalizedIncome(_underlyingAsset);\n\n        // interests from the timestamp of the last XYT transfer (before expiry) to now is entitled to the OT holders\n        // this means that the OT holders are getting some extra interests, at the expense of XYT holders\n        uint256 interestsAfterExpiry =\n            currentNormalizedIncome\n                .mul(redeemedAmount)\n                .div(lastNormalisedIncomeBeforeExpiry[_underlyingAsset][_expiry])\n                .sub(redeemedAmount);\n        aToken.transfer(_to, interestsAfterExpiry);\n\n        _settleDueInterests(tokens, _underlyingAsset, _expiry, _msgSender);\n        tokens.ot.burn(_msgSender, redeemedAmount);\n    }\n\n    // msg.sender needs to have both OT and XYT tokens\n    function redeemUnderlying(\n        address _msgSender,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToRedeem,\n        address _to\n    ) public override returns (uint256 redeemedAmount) {\n        BenchmarkTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n\n        require(tokens.ot.balanceOf(_msgSender) >= _amountToRedeem, \"Must have enough OT tokens\");\n        require(\n            tokens.xyt.balanceOf(_msgSender) >= _amountToRedeem,\n            \"Must have enough XYT tokens\"\n        );\n\n        IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n\n        aToken.transfer(_to, _amountToRedeem);\n\n        _settleDueInterests(tokens, _underlyingAsset, _expiry, _msgSender);\n\n        tokens.ot.burn(_msgSender, _amountToRedeem);\n        tokens.xyt.burn(_msgSender, _amountToRedeem);\n\n        return _amountToRedeem;\n    }\n\n    function tokenizeYield(\n        address _msgSender,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToTokenize,\n        address _to\n    ) public override onlyCore returns (address ot, address xyt) {\n        BenchmarkTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n\n        IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n        console.log(_msgSender, aToken.balanceOf(_msgSender), _amountToTokenize, address(aToken));\n        aToken.transferFrom(_msgSender, address(this), _amountToTokenize);\n\n        tokens.ot.mint(_to, _amountToTokenize);\n        tokens.xyt.mint(_to, _amountToTokenize);\n        lastNormalisedIncome[_underlyingAsset][_expiry][_to] = aaveLendingPoolCore\n            .getReserveNormalizedIncome(address(_underlyingAsset));\n\n        return (address(tokens.ot), address(tokens.xyt));\n    }\n\n    function _forgeFutureYieldToken(\n        address _underlyingAsset,\n        address _ot,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) internal nonReentrant() returns (address xyt) {\n        IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n\n        xyt = Factory.createContract(\n            type(BenchmarkFutureYieldToken).creationCode,\n            abi.encodePacked(aToken, _underlyingAsset),\n            abi.encode(_ot, _underlyingAsset, aToken, _name, _symbol, _decimals, _expiry)\n        );\n    }\n\n    function _forgeOwnershipToken(\n        address _underlyingAsset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) internal nonReentrant() returns (address ot) {\n        IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n\n        ot = Factory.createContract(\n            type(BenchmarkOwnershipToken).creationCode,\n            abi.encodePacked(aToken, _underlyingAsset),\n            abi.encode(aToken, _underlyingAsset, _name, _symbol, _decimals, _expiry)\n        );\n    }\n\n    function _settleDueInterests(\n        BenchmarkTokens memory _tokens,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _account\n    ) internal returns (uint256) {\n        uint256 principal = _tokens.xyt.balanceOf(_account);\n        uint256 Ix = lastNormalisedIncome[_underlyingAsset][_expiry][_account];\n\n        uint256 In;\n\n        if (block.timestamp >= _expiry) {\n            In = lastNormalisedIncomeBeforeExpiry[_underlyingAsset][_expiry];\n        } else {\n            In = aaveLendingPoolCore.getReserveNormalizedIncome(_underlyingAsset);\n            lastNormalisedIncomeBeforeExpiry[_underlyingAsset][_expiry] = In;\n        }\n        // first time getting XYT\n        if (Ix == 0) {\n            lastNormalisedIncome[_underlyingAsset][_expiry][_account] = In;\n            return 0;\n        }\n\n        uint256 dueInterests = principal.mul(In).div(Ix).sub(principal);\n\n        if (dueInterests > 0) {\n            IERC20 aToken = IERC20(aaveLendingPoolCore.getReserveATokenAddress(_underlyingAsset));\n            IERC20(aToken).transfer(_account, dueInterests);\n        }\n\n        lastNormalisedIncome[_underlyingAsset][_expiry][_account] = In;\n        // console.log(\"[contract] [Forge] in _settleDueInterests, interests = \", dueInterests);\n        return dueInterests;\n    }\n\n    function _getTokens(address _underlyingAsset, uint256 _expiry)\n        internal\n        view\n        returns (BenchmarkTokens memory _tokens)\n    {\n        IBenchmarkData data = core.data();\n        (_tokens.ot, _tokens.xyt) = data.getBenchmarkYieldTokens(\n            forgeId,\n            _underlyingAsset,\n            _expiry\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IAaveLendingPoolCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\ninterface IAaveLendingPoolCore {\n    function getReserveATokenAddress(address _reserveUnderlyingToken)\n        external\n        view\n        returns (address);\n\n    function getReserveNormalizedIncome(address _reserveUnderlyingToken)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/core/BenchmarkData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IBenchmarkData.sol\";\nimport \"../interfaces/IBenchmarkMarketFactory.sol\";\nimport \"../periphery/Permissions.sol\";\n\ncontract BenchmarkData is IBenchmarkData, Permissions {\n    mapping(address => bytes32) public override getForgeId;\n    mapping(bytes32 => address) public override getForgeAddress;\n    mapping(bytes32 => mapping(address => mapping(address => address))) public override getMarket;\n    mapping(bytes32 => mapping(address => mapping(uint256 => IBenchmarkYieldToken)))\n        public\n        override otTokens;\n    mapping(bytes32 => mapping(address => mapping(uint256 => IBenchmarkYieldToken)))\n        public\n        override xytTokens;\n    uint256 public override swapFee;\n    uint256 public override exitFee;\n    IBenchmark public override core;\n    mapping(address => bool) internal isMarket;\n    address[] private allMarkets;\n\n    constructor(address _governance, address _initializer) Permissions(_governance, _initializer) {}\n\n    modifier onlyCore() {\n        require(msg.sender == address(core), \"Benchmark: only core\");\n        _;\n    }\n\n    modifier onlyForge(bytes32 _forgeId) {\n        require(getForgeAddress[_forgeId] == msg.sender, \"Benchmark: only forge\");\n        _;\n    }\n\n    modifier onlyMarketFactory() {\n        require(msg.sender == address(core.factory()), \"Benchmark: only market factory\");\n        _;\n    }\n\n    function initialize(IBenchmark _core) external {\n        require(msg.sender == initializer, \"Benchmark: forbidden\");\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n\n        initializer = address(0);\n        core = _core;\n    }\n\n    function setCore(IBenchmark _core) external override initialized onlyGovernance {\n        require(address(_core) != address(0), \"Benchmark: zero address\");\n\n        core = _core;\n\n        emit CoreSet(address(_core));\n    }\n\n    /**********\n     *  FORGE *\n     **********/\n\n    function addForge(bytes32 _forgeId, address _forgeAddress)\n        external\n        override\n        initialized\n        onlyCore\n    {\n        getForgeId[_forgeAddress] = _forgeId;\n        getForgeAddress[_forgeId] = _forgeAddress;\n\n        emit ForgeAdded(_forgeId, _forgeAddress);\n    }\n\n    function removeForge(bytes32 _forgeId) external override initialized onlyCore {\n        address _forgeAddress = getForgeAddress[_forgeId];\n\n        getForgeAddress[_forgeId] = address(0);\n        getForgeId[_forgeAddress] = _forgeId;\n\n        emit ForgeRemoved(_forgeId, _forgeAddress);\n    }\n\n    function storeTokens(\n        bytes32 _forgeId,\n        address _ot,\n        address _xyt,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external override initialized onlyForge(_forgeId) {\n        otTokens[_forgeId][_underlyingAsset][_expiry] = IBenchmarkYieldToken(_ot);\n        xytTokens[_forgeId][_underlyingAsset][_expiry] = IBenchmarkYieldToken(_xyt);\n    }\n\n    function getBenchmarkYieldTokens(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external view override returns (IBenchmarkYieldToken ot, IBenchmarkYieldToken xyt) {\n        ot = otTokens[_forgeId][_underlyingAsset][_expiry];\n        xyt = xytTokens[_forgeId][_underlyingAsset][_expiry];\n    }\n\n    function isValidXYT(address _xyt) external view override returns (bool) {\n        address forge = IBenchmarkYieldToken(_xyt).forge();\n        return getForgeId[forge] != bytes32(0);\n    }\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    function addMarket(address _market) external override initialized onlyMarketFactory {\n        allMarkets.push(_market);\n    }\n\n    function setMarketFees(uint256 _swapFee, uint256 _exitFee) external override onlyGovernance {\n        swapFee = _swapFee;\n        exitFee = _exitFee;\n    }\n\n    function storeMarket(\n        bytes32 _forgeId,\n        address _xyt,\n        address _token,\n        address _market\n    ) external override initialized onlyMarketFactory {\n        getMarket[_forgeId][_xyt][_token] = _market;\n        isMarket[_market] = true;\n    }\n\n    function allMarketsLength() external view override returns (uint256) {\n        return allMarkets.length;\n    }\n\n    function getAllMarkets() public view override returns (address[] memory) {\n        return allMarkets;\n    }\n}\n"
    },
    "contracts/mock/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        _setupDecimals(_decimals);\n        _mint(msg.sender, 10**(21 + 24));\n    }\n}\n"
    },
    "contracts/interfaces/IUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IUSDT is IERC20 {\n    function issue(uint256 amount) external;\n}\n"
    },
    "contracts/playground/TestUsdtTransferFrom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IUSDT.sol\";\n\ncontract TestUsdtTransferFrom {\n    function testTransferFrom(address usdtAddress, uint256 amount) public {\n        require(IUSDT(usdtAddress).transferFrom(msg.sender, address(this), amount));\n    }\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Aave ERC20 AToken\n *\n * @dev Implementation of the interest bearing token for the DLP protocol.\n * @author Aave\n */\ninterface IAToken is IERC20 {\n    /**\n     * @dev gives allowance to an address to execute the interest redirection\n     * on behalf of the caller.\n     * @param _to the address to which the interest will be redirected. Pass address(0) to reset\n     * the allowance.\n     **/\n    function allowInterestRedirectionTo(address _to) external;\n\n    /**\n     * @dev calculates the balance of the user, which is the\n     * principal balance + interest generated by the principal balance + interest\n     * generated by the redirected balance\n     * @param _user the user for which the balance is being calculated\n     * @return the total balance of the user\n     **/\n    /* function balanceOf(address _user) external view returns (uint256); */\n\n    /**\n     * @dev returns the last index of the user, used to calculate the balance of the user\n     * @param _user address of the user\n     * @return the last user index\n     **/\n    function getUserIndex(address _user) external view returns (uint256);\n\n    /**\n     * @dev returns the address to which the interest is redirected\n     * @param _user address of the user\n     * @return 0 if there is no redirection, an address otherwise\n     **/\n    function getInterestRedirectionAddress(address _user) external view returns (address);\n\n    /**\n     * @dev returns the redirected balance of the user. The redirected balance is the balance\n     * redirected by other accounts to the user, that is accrueing interest for him.\n     * @param _user address of the user\n     * @return the total redirected balance\n     **/\n    function getRedirectedBalance(address _user) external view returns (uint256);\n\n    /**\n     * @dev returns the principal balance of the user. The principal balance is the last\n     * updated stored balance, which does not consider the perpetually accruing interest.\n     * @param _user the address of the user\n     * @return the principal balance of the user\n     **/\n    function principalBalanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev redirects the interest generated to a target address.\n     * when the interest is redirected, the user balance is added to\n     * the recepient redirected balance.\n     * @param _to the address to which the interest will be redirected\n     **/\n    function redirectInterestStream(address _to) external;\n\n    /**\n     * @dev redirects the interest generated by _from to a target address.\n     * when the interest is redirected, the user balance is added to\n     * the recepient redirected balance. The caller needs to have allowance on\n     * the interest redirection to be able to execute the function.\n     * @param _from the address of the user whom interest is being redirected\n     * @param _to the address to which the interest will be redirected\n     **/\n    function redirectInterestStreamOf(address _from, address _to) external;\n\n    /**\n     * @dev redeems aToken for the underlying asset\n     * @param _amount the amount being redeemed\n     **/\n    function redeem(uint256 _amount) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}